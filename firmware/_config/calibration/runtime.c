#include "../defs.h"

//---------------------------------------------------------
// runtime.c
//
// This file contains a single routine configure_io(),
// which uses values "DEP_L" and "DEP_R" generated by the
// calibration program, and uses them to create the
// correct bitstream for programming I/O.  The user program
// only needs to specify the *intended* configuration by
// writing values to reg_mprj_io(*) at the top of the
// program, then call configure_io() in place of triggering
// the automatic configuration loading (which is done in
// the middle of this routine).
//
// This routine saves the original intended configuration
// data and restores it after programming so that the
// housekeeping registers match the actual configuration
// at the target GPIOs.
//
//---------------------------------------------------------
// Written by Tim Edwards
// February 12, 2023
//---------------------------------------------------------

/*------------------------------------------------------*/
/* Calibration result is defined here, or the two	*/
/* definitions DEP_R and DEP_L may be passed on the	*/
/* compile line to compile the program for any specific	*/
/* calibrated chip.					*/
/*------------------------------------------------------*/

#ifndef DEP_R
#define DEP_R 0x337c
#endif /* DEP_R */

#ifndef DEP_L
#define DEP_L 0x124
#endif /* DEP_L */

// Recast the reg_mprj_io_* definitions as a single
// parameterized definition, for simplicity

#define reg_mprj_io(i) (*(volatile uint32_t*)(0x26000024 + (i << 2)))

void
configure_io()
{
    unsigned char channel, i;
    unsigned short value;

    /* Main config storage is up to 247 bits of data */
    unsigned char config_data[31];

    /* Storage to save and restore the existing configuration */
    unsigned short save_data[38];

    /* Save the intended calibration */
    for (i = 0; i < 38; i++)
	save_data[i] = reg_mprj_io(i);

    for (i = 0; i < 31; i++)
	config_data[i] = 0;

    for (channel = 19; channel > 0; channel--) {

	/* Move configuration up by 12 bits */
	for (i = 29; i > 0; i--) {
	    config_data[i + 1] = (config_data[i] << 4) | (config_data[i - 1] >> 4);
	}
	config_data[1] = config_data[0] << 4;
	config_data[0] = 0;

	/* If there is a dependent hold violation, then add 1 to the end of 1 chains */
	if (((unsigned short)DEP_R & (1 << channel)) != 0)
	{
	    for (i = 30; i > 0; i--) {
		config_data[i] |= (config_data[i] << 1) | (config_data[i - 1] >> 7);
	    }
	}

	/* Get intended value for channel */
	value = save_data[channel];

	/* Add new configuration at low end */
    	config_data[1] |= (value >> 8);
    	config_data[0] = value & 0xff;
    }

    // Set the configuration (8 bit data into 13 bit registers)
    reg_mprj_io_0  = (config_data[0] >> 0)  | (config_data[1] << 8);
    reg_mprj_io_1  = (config_data[1] >> 5)  | (config_data[2] << 3) | (config_data[3] << 11);
    reg_mprj_io_2  = (config_data[3] >> 2)  | (config_data[4] << 6);
    reg_mprj_io_3  = (config_data[4] >> 7)  | (config_data[5] << 1) | (config_data[6] << 9);
    reg_mprj_io_4  = (config_data[6] >> 4)  | (config_data[7] << 4) | (config_data[8] << 12);
    reg_mprj_io_5  = (config_data[8] >> 1)  | (config_data[9] << 7);
    reg_mprj_io_6  = (config_data[9] >> 6)  | (config_data[10] << 2) | (config_data[11] << 10);
    reg_mprj_io_7  = (config_data[11] >> 3) | (config_data[12] << 5);
    reg_mprj_io_8  = (config_data[13] >> 0) | (config_data[14] << 8);
    reg_mprj_io_9  = (config_data[14] >> 5) | (config_data[15] << 3) | (config_data[16] << 11);
    reg_mprj_io_10 = (config_data[16] >> 2) | (config_data[17] << 6);
    reg_mprj_io_11 = (config_data[17] >> 7) | (config_data[18] << 1) | (config_data[19] << 9);
    reg_mprj_io_12 = (config_data[19] >> 4) | (config_data[20] << 4) | (config_data[21] << 12);
    reg_mprj_io_13 = (config_data[21] >> 1) | (config_data[22] << 7);
    reg_mprj_io_14 = (config_data[22] >> 6) | (config_data[23] << 2) | (config_data[24] << 10);
    reg_mprj_io_15 = (config_data[24] >> 3) | (config_data[25] << 5);
    reg_mprj_io_16 = (config_data[26] >> 0) | (config_data[27] << 8);
    reg_mprj_io_17 = (config_data[27] >> 5) | (config_data[28] << 3) | (config_data[29] << 11);
    reg_mprj_io_18 = (config_data[29] >> 2) | (config_data[30] << 6);

    for (i = 0; i < 31; i++)
	config_data[i] = 0;

    for (channel = 19; channel > 0; channel--) {
	/* Move configuration up by 12 bits */
	for (i = 29; i > 0; i--) {
	    config_data[i + 1] = (config_data[i] << 4) | (config_data[i - 1] >> 4);
	}
	config_data[1] = config_data[0] << 4;
	config_data[0] = 0;

	/* If there is a dependent hold violation, then add 1 to the end of 1 chains */
	if (((unsigned short)DEP_L & (1 << channel)) != 0)
	{
	    for (i = 30; i > 0; i--) {
		config_data[i] |= (config_data[i] << 1) | (config_data[i - 1] >> 7);
	    }
	}

	/* Get intended value for channel */
	value = save_data[38 - channel];

	/* Add new configuration at low end */
    	config_data[1] |= (value >> 8);
    	config_data[0] = value & 0xff;
    }

    // Set the configuration (8 bit data into 13 bit registers)
    reg_mprj_io_37 = (config_data[0] >> 0)  | (config_data[1] << 8);
    reg_mprj_io_36 = (config_data[1] >> 5)  | (config_data[2] << 3) | (config_data[3] << 11);
    reg_mprj_io_35 = (config_data[3] >> 2)  | (config_data[4] << 6);
    reg_mprj_io_34 = (config_data[4] >> 7)  | (config_data[5] << 1) | (config_data[6] << 9);
    reg_mprj_io_33 = (config_data[6] >> 4)  | (config_data[7] << 4) | (config_data[8] << 12);
    reg_mprj_io_32 = (config_data[8] >> 1)  | (config_data[9] << 7);
    reg_mprj_io_31 = (config_data[9] >> 6)  | (config_data[10] << 2) | (config_data[11] << 10);
    reg_mprj_io_30 = (config_data[11] >> 3) | (config_data[12] << 5);
    reg_mprj_io_29 = (config_data[13] >> 0) | (config_data[14] << 8);
    reg_mprj_io_28 = (config_data[14] >> 5) | (config_data[15] << 3) | (config_data[16] << 11);
    reg_mprj_io_27 = (config_data[16] >> 2) | (config_data[17] << 6);
    reg_mprj_io_26 = (config_data[17] >> 7) | (config_data[18] << 1) | (config_data[19] << 9);
    reg_mprj_io_25 = (config_data[19] >> 4) | (config_data[20] << 4) | (config_data[21] << 12);
    reg_mprj_io_24 = (config_data[21] >> 1) | (config_data[22] << 7);
    reg_mprj_io_23 = (config_data[22] >> 6) | (config_data[23] << 2) | (config_data[24] << 10);
    reg_mprj_io_22 = (config_data[24] >> 3) | (config_data[25] << 5);
    reg_mprj_io_21 = (config_data[26] >> 0) | (config_data[27] << 8);
    reg_mprj_io_20 = (config_data[27] >> 5) | (config_data[28] << 3) | (config_data[29] << 11);
    reg_mprj_io_19 = (config_data[29] >> 2) | (config_data[30] << 6);

    // Now load the configuration
    reg_mprj_xfer = 1;
    while (reg_mprj_xfer == 1);

    /* Restore the intended calibration */
    for (i = 0; i < 38; i++)
	reg_mprj_io(i) = save_data[i];
}

